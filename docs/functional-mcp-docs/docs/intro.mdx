---
title: Introduction
description: Transform any MCP server into a native Python module automatically
sidebar_position: 1
---

# Welcome to functional-mcp

**Every MCP server is a Python module. Automatically.**

```python
from functional_mcp import load_server

# Any MCP server ‚Üí Python
server = load_server("npx -y @modelcontextprotocol/server-filesystem /tmp")

# Call tools
files = server.list_directory(path="/tmp")

# Or access with metadata
list_tool = server.tools.list_directory
print(list_tool.schema.toDict())  # See what it needs
files = list_tool(path="/tmp")
```

No learning. No setup. Full transparency.

## What Is This?

MCP servers expose tools, resources, and prompts in a standard format.

**functional-mcp translates that into Python. Instantly.**

```python
from functional_mcp import load_server

server = load_server("npx your-mcp-server")

# Tools ‚Üí callable objects with metadata
search = server.tools.search
print(search.name)          # "search"
print(search.description)   # "Search for items..."
print(search.schema.toDict())  # Full schema as dict

# Call and get hydrated Python objects (not just JSON!)
result = search(query="test")
# Returns real Python types:
#   - datetime objects (not ISO strings)
#   - UUID objects (not string IDs)
#   - Pydantic models (not dicts)
#   - Primitives unwrapped (8 not {"result": 8})

# Resources ‚Üí attributes
config = server.CONFIG  # Static resource

# Prompts ‚Üí template functions
prompt = server.format_prompt(style="formal")
```

**Every tool is first-class. Hydrated objects. Full transparency.**

## The Magic

### Before

**Step 1:** Find MCP server
**Step 2:** Read MCP documentation
**Step 3:** Learn the protocol
**Step 4:** Write integration code
**Step 5:** Handle edge cases
**Step 6:** Maybe it works

### After

```python
from functional_mcp import load_server
server = load_server("the-mcp-server")
# Done.
```

**One line. Everything works.**

## Key Features

- üöÄ **Zero Configuration** - Load any MCP server with one function call
- üéØ **Full Type Safety** - Auto-generated types for IDE autocomplete
- üîß **First-Class Tools** - Tools are callable objects with complete metadata
- üêç **Pythonic** - Snake case conversion, hydrated objects, intuitive API
- üåê **Universal** - Works with stdio, HTTP, and SSE MCP servers
- ü§ñ **Framework-Agnostic** - Integrates with DSPy, LangChain, Remodl, etc.
- ‚ö° **Async Support** - Full async/await capabilities
- üîê **Built-in Auth** - OAuth, Bearer tokens, custom handlers

## Quick Links

- [Installation](/docs/getting-started/installation) - Get started in seconds
- [Quickstart](/docs/getting-started/quickstart) - Your first MCP server
- [Core Concepts](/docs/core-concepts/architecture) - How it works
- [API Reference](/docs/api/loader) - Complete API documentation

## Philosophy

**MCP servers are the future of service integration.**

They describe tools, resources, and prompts in a standard way.

**functional-mcp makes that future instant.**

No SDK per service. No integration per tool. No learning per API.

**Just Python.**

---

<p align="center">
  <strong>MCP ‚Üí Python. Automatically. Universally.</strong>
</p>

<p align="center">
  Made with ‚ù§Ô∏è by <a href="https://remodl.ai">RemodlAI</a>
</p>
